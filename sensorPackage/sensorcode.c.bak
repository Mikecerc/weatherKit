// =============================================================================
// I2C Helper Functions
// =============================================================================

static bool i2c_initialized = false;

static esp_err_t i2c_init_bus(void)
{
    if (i2c_initialized) return ESP_OK;
    
    i2c_config_t conf = {
        .mode = I2C_MODE_MASTER,
        .sda_io_num = PIN_I2C_SDA,
        .scl_io_num = PIN_I2C_SCL,
        .sda_pullup_en = GPIO_PULLUP_ENABLE,
        .scl_pullup_en = GPIO_PULLUP_ENABLE,
        .master.clk_speed = I2C_FREQ_HZ,
    };
    
    esp_err_t ret = i2c_param_config(I2C_HOST, &conf);
    if (ret != ESP_OK) return ret;
    
    ret = i2c_driver_install(I2C_HOST, conf.mode, 0, 0, 0);
    if (ret == ESP_OK) {
        i2c_initialized = true;
    }
    return ret;
}

static esp_err_t i2c_write_byte(uint8_t addr, uint8_t reg, uint8_t data)
{
    uint8_t write_buf[2] = {reg, data};
    return i2c_master_write_to_device(I2C_HOST, addr, write_buf, 2, pdMS_TO_TICKS(1000));
}

static esp_err_t i2c_read_bytes(uint8_t addr, uint8_t reg, uint8_t *data, size_t len)
{
    return i2c_master_write_read_device(I2C_HOST, addr, &reg, 1, data, len, pdMS_TO_TICKS(1000));
}

// =============================================================================
// AHT20 Temperature/Humidity Sensor
// =============================================================================

#define AHT20_ADDR          0x38
#define AHT20_CMD_INIT      0xBE
#define AHT20_CMD_MEASURE   0xAC
#define AHT20_CMD_RESET     0xBA

static bool aht20_initialized = false;

esp_err_t aht20_init(void)
{
    esp_err_t ret = i2c_init_bus();
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "AHT20: I2C init failed: %s", esp_err_to_name(ret));
        return ret;
    }
    
    ESP_LOGI(TAG, "Initializing AHT20...");
    
    // Wait for sensor to be ready after power-on
    vTaskDelay(pdMS_TO_TICKS(40));
    
    // Send initialization command
    uint8_t init_cmd[3] = {AHT20_CMD_INIT, 0x08, 0x00};
    ret = i2c_master_write_to_device(I2C_HOST, AHT20_ADDR, init_cmd, 3, pdMS_TO_TICKS(1000));
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "AHT20: Init command failed: %s", esp_err_to_name(ret));
        return ret;
    }
    
    vTaskDelay(pdMS_TO_TICKS(10));
    
    aht20_initialized = true;
    ESP_LOGI(TAG, "AHT20 initialized");
    return ESP_OK;
}

esp_err_t aht20_read(aht20_data_t *data)
{
    if (!aht20_initialized) {
        ESP_LOGE(TAG, "AHT20 not initialized");
        return ESP_ERR_INVALID_STATE;
    }
    
    memset(data, 0, sizeof(aht20_data_t));
    
    // Trigger measurement
    uint8_t measure_cmd[3] = {AHT20_CMD_MEASURE, 0x33, 0x00};
    esp_err_t ret = i2c_master_write_to_device(I2C_HOST, AHT20_ADDR, measure_cmd, 3, pdMS_TO_TICKS(1000));
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "AHT20: Measure command failed");
        return ret;
    }
    
    // Wait for measurement (80ms typical)
    vTaskDelay(pdMS_TO_TICKS(80));
    
    // Read data (7 bytes: status + humidity[20bit] + temperature[20bit] + CRC)
    uint8_t buf[7];
    ret = i2c_master_read_from_device(I2C_HOST, AHT20_ADDR, buf, 7, pdMS_TO_TICKS(1000));
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "AHT20: Read failed");
        return ret;
    }
    
    // Check if measurement is ready (bit 7 should be 0)
    if (buf[0] & 0x80) {
        ESP_LOGW(TAG, "AHT20: Measurement not ready");
        return ESP_ERR_INVALID_STATE;
    }
    
    // Extract humidity (20 bits)
    uint32_t humidity_raw = ((uint32_t)buf[1] << 12) | ((uint32_t)buf[2] << 4) | (buf[3] >> 4);
    data->humidity_rh = (float)humidity_raw / 1048576.0f * 100.0f;
    
    // Extract temperature (20 bits)
    uint32_t temp_raw = (((uint32_t)buf[3] & 0x0F) << 16) | ((uint32_t)buf[4] << 8) | buf[5];
    data->temperature_c = (float)temp_raw / 1048576.0f * 200.0f - 50.0f;
    
    data->valid = true;
    
    ESP_LOGD(TAG, "AHT20: Temp=%.2fÂ°C, Humidity=%.2f%%", data->temperature_c, data->humidity_rh);
    return ESP_OK;
}

// =============================================================================
// HX710B Pressure Sensor
// =============================================================================

static int hx710b_sck = -1;
static int hx710b_dout = -1;
static bool hx710b_initialized = false;
static int32_t hx710b_zero_offset = 0;
static float hx710b_scale_factor = 0.01f; // Default scale, calibrate for accuracy

esp_err_t hx710b_init(int sck_pin, int dout_pin)
{
    ESP_LOGI(TAG, "Initializing HX710B on SCK=%d, DOUT=%d", sck_pin, dout_pin);
    
    hx710b_sck = sck_pin;
    hx710b_dout = dout_pin;
    
    // Configure SCK as output
    gpio_reset_pin(hx710b_sck);
    gpio_set_direction(hx710b_sck, GPIO_MODE_OUTPUT);
    gpio_set_level(hx710b_sck, 0);
    
    // Configure DOUT as input
    gpio_reset_pin(hx710b_dout);
    gpio_set_direction(hx710b_dout, GPIO_MODE_INPUT);
    
    // Power up and wait
    vTaskDelay(pdMS_TO_TICKS(100));
    
    hx710b_initialized = true;
    ESP_LOGI(TAG, "HX710B initialized");
    return ESP_OK;
}

static int32_t hx710b_read_raw(void)
{
    // Wait for DOUT to go low (data ready)
    int timeout = 100;
    while (gpio_get_level(hx710b_dout) && timeout > 0) {
        vTaskDelay(pdMS_TO_TICKS(1));
        timeout--;
    }
    
    if (timeout == 0) {
        ESP_LOGW(TAG, "HX710B: Timeout waiting for data ready");
        return 0;
    }
    
    // Read 24 bits (MSB first)
    int32_t value = 0;
    for (int i = 0; i < 24; i++) {
        gpio_set_level(hx710b_sck, 1);
        esp_rom_delay_us(1);
        value = (value << 1) | gpio_get_level(hx710b_dout);
        gpio_set_level(hx710b_sck, 0);
        ets_delay_us(1);
    }
    
    // One extra pulse to set gain (40Hz mode)
    gpio_set_level(hx710b_sck, 1);
    ets_delay_us(1);
    gpio_set_level(hx710b_sck, 0);
    ets_delay_us(1);
    
    // Convert to signed 24-bit
    if (value & 0x800000) {
        value |= 0xFF000000;
    }
    
    return value;
}

esp_err_t hx710b_read(hx710b_data_t *data)
{
    if (!hx710b_initialized) {
        ESP_LOGE(TAG, "HX710B not initialized");
        return ESP_ERR_INVALID_STATE;
    }
    
    memset(data, 0, sizeof(hx710b_data_t));
    
    data->raw_value = hx710b_read_raw();
    
    // Apply calibration
    int32_t adjusted = data->raw_value - hx710b_zero_offset;
    data->pressure_hpa = (float)adjusted * hx710b_scale_factor + 1013.25f;
    
    data->valid = true;
    
    ESP_LOGD(TAG, "HX710B: Raw=%ld, Pressure=%.2f hPa", (long)data->raw_value, data->pressure_hpa);
    return ESP_OK;
}

esp_err_t hx710b_calibrate(float known_pressure_hpa)
{
    if (!hx710b_initialized) return ESP_ERR_INVALID_STATE;
    
    ESP_LOGI(TAG, "Calibrating HX710B to %.2f hPa", known_pressure_hpa);
    
    // Average multiple readings
    int32_t sum = 0;
    const int samples = 10;
    for (int i = 0; i < samples; i++) {
        sum += hx710b_read_raw();
        vTaskDelay(pdMS_TO_TICKS(100));
    }
    int32_t avg = sum / samples;
    
    hx710b_zero_offset = avg;
    hx710b_scale_factor = (known_pressure_hpa - 1013.25f) / (float)avg;
    
    ESP_LOGI(TAG, "Calibration: offset=%ld, scale=%.6f", (long)hx710b_zero_offset, hx710b_scale_factor);
    return ESP_OK;
}

// =============================================================================
// AS3935 Lightning Detector
// =============================================================================

#define AS3935_REG_AFE_GB       0x00
#define AS3935_REG_PWD          0x00
#define AS3935_REG_NF_LEV       0x01
#define AS3935_REG_WDTH         0x01
#define AS3935_REG_SREJ         0x02
#define AS3935_REG_LCO_FDIV     0x03
#define AS3935_REG_INT          0x03
#define AS3935_REG_DISTANCE     0x07
#define AS3935_REG_DISP_LCO     0x08
#define AS3935_REG_DISP_SRCO    0x08
#define AS3935_REG_DISP_TRCO    0x08
#define AS3935_REG_TUNE_CAP     0x08

static bool as3935_initialized = false;
static int as3935_irq_pin = -1;
static uint32_t strike_count = 0;

esp_err_t as3935_init(int irq_pin)
{
    esp_err_t ret = i2c_init_bus();
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "AS3935: I2C init failed");
        return ret;
    }
    
    ESP_LOGI(TAG, "Initializing AS3935...");
    
    as3935_irq_pin = irq_pin;
    
    // Configure IRQ pin if provided
    if (irq_pin >= 0) {
        gpio_reset_pin(irq_pin);
        gpio_set_direction(irq_pin, GPIO_MODE_INPUT);
        gpio_set_pull_mode(irq_pin, GPIO_PULLUP_ONLY);
    }
    
    // Reset device
    uint8_t reg_val;
    ret = i2c_read_bytes(I2C_ADDR_AS3935, AS3935_REG_PWD, &reg_val, 1);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "AS3935: Failed to read register (not connected?)");
        return ret;
    }
    
    // Set to indoor mode by default
    ret = i2c_write_byte(I2C_ADDR_AS3935, AS3935_REG_AFE_GB, 0x24);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "AS3935: Config failed");
        return ret;
    }
    
    vTaskDelay(pdMS_TO_TICKS(2));
    
    as3935_initialized = true;
    strike_count = 0;
    ESP_LOGI(TAG, "AS3935 initialized");
    return ESP_OK;
}

as3935_interrupt_t as3935_check_interrupt(void)
{
    if (!as3935_initialized) return AS3935_INT_NONE;
    
    uint8_t int_val;
    esp_err_t ret = i2c_read_bytes(I2C_ADDR_AS3935, AS3935_REG_INT, &int_val, 1);
    if (ret != ESP_OK) return AS3935_INT_NONE;
    
    int_val &= 0x0F;
    return (as3935_interrupt_t)int_val;
}

esp_err_t as3935_read(as3935_data_t *data)
{
    if (!as3935_initialized) {
        ESP_LOGE(TAG, "AS3935 not initialized");
        return ESP_ERR_INVALID_STATE;
    }
    
    memset(data, 0, sizeof(as3935_data_t));
    
    // Check interrupt type
    data->type = as3935_check_interrupt();
    
    if (data->type == AS3935_INT_LIGHTNING) {
        // Read distance
        uint8_t dist;
        esp_err_t ret = i2c_read_bytes(I2C_ADDR_AS3935, AS3935_REG_DISTANCE, &dist, 1);
        if (ret == ESP_OK) {
            data->distance_km = dist & 0x3F;
            if (data->distance_km == 0x3F) {
                data->distance_km = 0xFF; // Out of range
            }
            data->valid = true;
            strike_count++;
            ESP_LOGI(TAG, "AS3935: Lightning detected at %d km", data->distance_km);
        }
    }
    
    return ESP_OK;
}

esp_err_t as3935_set_indoor_outdoor(bool indoor)
{
    if (!as3935_initialized) return ESP_ERR_INVALID_STATE;
    
    uint8_t afe_val = indoor ? 0x24 : 0x1C;
    return i2c_write_byte(I2C_ADDR_AS3935, AS3935_REG_AFE_GB, afe_val);
}

void as3935_clear_statistics(void)
{
    strike_count = 0;
}

uint32_t as3935_get_strike_count(void)
{
    return strike_count;
}

// =============================================================================
// Unified Sensor Interface
// =============================================================================

esp_err_t sensors_init_all(int hx710b_sck, int hx710b_dout, int as3935_irq)
{
    ESP_LOGI(TAG, "========== Initializing All Sensors ==========");
    
    bool any_success = false;
    
    // AHT20
    if (aht20_init() == ESP_OK) {
        ESP_LOGI(TAG, "AHT20 initialized");
        any_success = true;
    } else {
        ESP_LOGW(TAG, "AHT20 failed");
    }
    
    // HX710B
    if (hx710b_init(hx710b_sck, hx710b_dout) == ESP_OK) {
        ESP_LOGI(TAG, "HX710B initialized");
        any_success = true;
    } else {
        ESP_LOGW(TAG, "HX710B failed");
    }
    
    // AS3935
    if (as3935_init(as3935_irq) == ESP_OK) {
        ESP_LOGI(TAG, "AS3935 initialized");
        any_success = true;
    } else {
        ESP_LOGW(TAG, "AS3935 failed");
    }
    
    ESP_LOGI(TAG, "==============================================");
    
    return any_success ? ESP_OK : ESP_FAIL;
}

esp_err_t sensors_read_all(weather_data_t *data)
{
    if (!data) return ESP_ERR_INVALID_ARG;
    
    memset(data, 0, sizeof(weather_data_t));
    
    // Read AHT20
    if (aht20_initialized) {
        aht20_data_t aht;
        if (aht20_read(&aht) == ESP_OK && aht.valid) {
            data->temperature_c = aht.temperature_c;
            data->humidity_rh = aht.humidity_rh;
            data->temp_humidity_valid = true;
            data->any_valid = true;
        }
    }
    
    // Read HX710B
    if (hx710b_initialized) {
        hx710b_data_t hx;
        if (hx710b_read(&hx) == ESP_OK && hx.valid) {
            data->pressure_hpa = hx.pressure_hpa;
            data->pressure_valid = true;
            data->any_valid = true;
        }
    }
    
    // Read AS3935
    if (as3935_initialized) {
        as3935_data_t as;
        if (as3935_read(&as) == ESP_OK) {
            if (as.type == AS3935_INT_LIGHTNING && as.valid) {
                data->lightning_distance_km = as.distance_km;
                data->lightning_energy = as.energy;
            }
            data->lightning_strike_count = as3935_get_strike_count();
            data->lightning_valid = true;
        }
    }
    
    return data->any_valid ? ESP_OK : ESP_FAIL;
}

void sensors_run_diagnostics(void)