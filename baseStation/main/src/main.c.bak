#include <stdio.h>
#include <stdlib.h>
#include "esp_log.h"
#include "esp_random.h"
#include "esp_timer.h"
#include "nvs_flash.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/queue.h"
#include "display.h"
#include "ui.h"
#include "buttons.h"
#include "storm_tracker.h"
#include "lora.h"
#include "lora_protocol.h"

static const char *TAG = "main";

// Queue for weather data updates from LoRa
static QueueHandle_t weather_queue = NULL;

// Track last time we received data from sensor
static TickType_t last_sensor_data_time = 0;
#define SENSOR_TIMEOUT_MS       60000   // Consider sensor disconnected after 60s

// Track last processed lightning data to prevent double-counting
// We track two things:
// 1. last_processed_lightning_total - what we've recorded to storm tracker
// 2. pending_lightning - data waiting for ACK-ACK confirmation
static uint32_t last_confirmed_lightning_total = 0;  // Confirmed via ACK-ACK
static uint32_t pending_lightning_total = 0;         // Waiting for ACK-ACK
static uint8_t pending_lightning_count = 0;          // Strikes waiting to record
static float pending_lightning_closest = -1.0f;      // Closest distance for pending strikes

// ACK-ACK retry mechanism
// If we send WEATHER_ACK but don't receive ACK-ACK, resend the ACK
static uint8_t pending_ack_sequence = 0;             // Sequence we're waiting ACK-ACK for
static uint8_t pending_ack_src_id = 0;               // Device we sent ACK to
static TickType_t pending_ack_sent_time = 0;         // When we sent the ACK
static bool pending_ack_waiting = false;             // Are we waiting for ACK-ACK?
#define ACK_ACK_TIMEOUT_MS      2000                 // Resend ACK after 2 seconds
#define ACK_ACK_MAX_RETRIES     3                    // Give up after 3 retries
static uint8_t pending_ack_retries = 0;              // Current retry count

/**
 * @brief Button event callback - runs in button task context, keep minimal!
 * 
 * Navigation scheme:
 * - LEFT short: cycle through pages / menu items
 * - LEFT long: show info/help for current page
 * - RIGHT short: select (enter context or toggle option)
 * - RIGHT long: escape context (go back)
 * - BOTH long: toggle standby mode (display off, still receiving data)
 */

// Track if we just woke from standby - ignore events until all buttons released
static bool just_woke_from_standby = false;

static void button_callback(button_event_t event)
{
    // Ignore no-op events
    if (event == BUTTON_EVENT_NONE) return;
    
    // If in standby mode, ANY button press wakes the display
    if (ui_is_standby()) {
        ui_exit_standby();
        just_woke_from_standby = true;  // Set flag to ignore subsequent events
        return;  // Don't process further - just wake up
    }
    
    // If we just woke, ignore all events until ANY_PRESS stops coming
    // (meaning all buttons have been released)
    if (just_woke_from_standby) {
        if (event == BUTTON_ANY_PRESS) {
            // Still pressing - keep ignoring
            return;
        }
        // Check if this is a release event (SHORT events fire on release)
        // We want to ignore this first release
        if (event == BUTTON_LEFT_SHORT || event == BUTTON_RIGHT_SHORT ||
            event == BUTTON_LEFT_LONG || event == BUTTON_RIGHT_LONG ||
            event == BUTTON_BOTH_LONG) {
            just_woke_from_standby = false;  // Clear flag, next press will work
            return;  // But ignore this one
        }
    }
    
    // Normal operation - process button events
    switch (event) {
        case BUTTON_LEFT_SHORT:
            ui_cycle();      // Cycle pages or menu items
            break;
            
        case BUTTON_LEFT_LONG:
            ui_show_info();  // Show help/info for current page
            break;
            
        case BUTTON_RIGHT_SHORT:
            ui_select();     // Select / enter / toggle
            break;
            
        case BUTTON_RIGHT_LONG:
            ui_back();       // Escape current context
            break;
            
        case BUTTON_BOTH_LONG:
            ui_enter_standby();  // Enter standby mode
            break;
            
        case BUTTON_ANY_PRESS:
            // Already handled above for standby wake
            // No action needed in normal mode
            break;
            
        default:
            break;
    }
}

/**
 * @brief LoRa weather data callback - called when weather packet received
 * 
 * This runs in the LoRa RX task context, so keep it fast.
 * We just convert and queue the data for the main task.
 */
static void on_weather_received(uint8_t src_id, const weather_payload_t *data, int8_t rssi)
{
    ESP_LOGI(TAG, "Weather data from sensor 0x%02X (RSSI: %d dBm)", src_id, rssi);
    
    // Convert from protocol format to UI format
    weather_data_t weather = {
        .temperature = decode_temperature(data->temperature),
        .humidity = decode_humidity(data->humidity),
        .pressure = decode_pressure(data->pressure),
        .lightning_dist = -1.0f,                        // Will be set below if strikes present
        .lightning_count = data->lightning.strikes_since_ack,
        .lightning_total = data->lightning.total_count,
        .sensor_connected = true,
        
        // Sensor configuration echo
        .sensor_update_interval = data->config.update_interval,
        .sensor_tx_power = data->config.tx_power,       // Sensor's TX power (what sensor uses to send)
        .sensor_high_power = (data->config.flags & CFG_HIGH_POWER) != 0,
        .sensor_adaptive_power = (data->config.flags & CFG_ADAPTIVE_POWER) != 0,
        .sensor_rssi = data->last_base_rssi,            // RSSI sensor saw from base
        .sensor_uptime_sec = data->uptime_sec,
        
        // Base station link quality
        .base_rssi = rssi,                              // RSSI base saw from sensor
        .base_tx_power = 0,                             // Will be set from lora_get_status
        
        // Timing
        .last_rx_time_ms = (uint32_t)(esp_timer_get_time() / 1000)
    };
    
    // Get base TX power from lora status
    lora_status_t lora_st;
    lora_get_status(&lora_st);
    weather.base_tx_power = lora_st.tx_power;
    
    // Process lightning data - DON'T record yet, wait for ACK-ACK confirmation
    // This prevents double-counting if sensor misses our ACK and resends data
    // We cache the pending data and record it when ACK-ACK confirms deletion
    uint32_t new_strikes = 0;
    if (data->lightning.total_count > last_confirmed_lightning_total) {
        new_strikes = data->lightning.total_count - last_confirmed_lightning_total;
        ESP_LOGI(TAG, "  Pending lightning: %lu strikes (confirmed %lu -> pending %lu)",
                 (unsigned long)new_strikes,
                 (unsigned long)last_confirmed_lightning_total,
                 (unsigned long)data->lightning.total_count);
        
        // Cache pending lightning data - will be recorded when ACK-ACK received
        pending_lightning_total = data->lightning.total_count;
        pending_lightning_count = (uint8_t)(new_strikes > 255 ? 255 : new_strikes);
        
        // Find the closest strike for display and pending recording
        uint8_t closest = lightning_data_closest(&data->lightning);
        if (closest < 255) {
            weather.lightning_dist = (float)closest;
            pending_lightning_closest = (float)closest;
        }
        
        ESP_LOGI(TAG, "    Cached %d strikes at closest distance: %.0f km (awaiting ACK-ACK)", 
                 pending_lightning_count, pending_lightning_closest);
    } else if (data->lightning.total_count > last_confirmed_lightning_total && 
               data->lightning.total_count == pending_lightning_total) {
        // Sensor is resending same pending data (missed our ACK)
        // Just update display, keep existing pending data
        uint8_t closest = lightning_data_closest(&data->lightning);
        if (closest < 255) {
            weather.lightning_dist = (float)closest;
        }
        ESP_LOGD(TAG, "  Lightning data resent (awaiting ACK-ACK, pending=%lu)",
                 (unsigned long)pending_lightning_total);
    } else if (data->lightning.strikes_since_ack > 0) {
        // Sensor has pending strikes but we've already confirmed them
        // This shouldn't happen normally - sensor should have cleared after ACK-ACK
        uint8_t closest = lightning_data_closest(&data->lightning);
        if (closest < 255) {
            weather.lightning_dist = (float)closest;
        }
        ESP_LOGW(TAG, "  Unexpected: sensor has strikes but total=%lu <= confirmed=%lu",
                 (unsigned long)data->lightning.total_count,
                 (unsigned long)last_confirmed_lightning_total);
    }
    
    // Update weather.lightning_count to reflect only new strikes this packet
    weather.lightning_count = (uint8_t)(new_strikes > 255 ? 255 : new_strikes);
    
    // Record weather in storm tracker
    storm_tracker_record_weather(weather.temperature, weather.humidity, weather.pressure);
    
    // Update last received time
    last_sensor_data_time = xTaskGetTickCount();
    
    // Send to queue for UI task
    if (weather_queue != NULL) {
        xQueueOverwrite(weather_queue, &weather);
    }
    
    ESP_LOGI(TAG, "  Temp: %.1fÂ°C, Humidity: %.1f%%, Pressure: %.1f hPa, Lightning: %d/%lu",
             weather.temperature, weather.humidity, weather.pressure,
             weather.lightning_count, (unsigned long)weather.lightning_total);
}

/**
 * @brief LoRa status callback - called when status/heartbeat packet received
 */
static void on_status_received(uint8_t src_id, const status_payload_t *data, int8_t rssi)
{
    ESP_LOGI(TAG, "Status from sensor 0x%02X: Battery %d%% (%dmV), RSSI %d",
             src_id, data->battery_percent, data->battery_mv, rssi);
    
    if (data->error_flags) {
        ESP_LOGW(TAG, "  Sensor errors: 0x%02X", data->error_flags);
    }
    
    // Update last received time (status counts as valid communication)
    last_sensor_data_time = xTaskGetTickCount();
}

/**
 * @brief LoRa ACK-ACK callback - called when sensor confirms it cleared lightning data
 * 
 * This is the final step of the three-way handshake:
 * 1. Sensor sends WEATHER_DATA with lightning strikes
 * 2. Base sends WEATHER_ACK
 * 3. Sensor clears lightning and sends WEATHER_ACK_ACK (this callback)
 * 
 * Only now do we record the lightning to storm tracker - we're certain
 * the sensor won't resend the same data.
 */
static void on_weather_ack_ack_received(const weather_ack_ack_payload_t *data)
{
    ESP_LOGI(TAG, "ACK-ACK received: lightning_total=%lu (confirmed)", (unsigned long)data->lightning_total);
    
    // Verify this matches our pending data
    if (data->lightning_total != pending_lightning_total) {
        ESP_LOGW(TAG, "  ACK-ACK total mismatch: expected %lu, got %lu",
                 (unsigned long)pending_lightning_total, (unsigned long)data->lightning_total);
        // Still update confirmed total to stay in sync with sensor
    }
    
    // Now safe to record the pending lightning to storm tracker
    if (pending_lightning_count > 0 && pending_lightning_closest >= 0) {
        for (uint8_t i = 0; i < pending_lightning_count; i++) {
            storm_tracker_record_lightning(pending_lightning_closest);
        }
        ESP_LOGI(TAG, "  Recorded %d strikes at %.0f km to storm tracker", 
                 pending_lightning_count, pending_lightning_closest);
    }
    
    // Update confirmed total and clear pending data
    last_confirmed_lightning_total = data->lightning_total;
    pending_lightning_total = 0;
    pending_lightning_count = 0;
    pending_lightning_closest = -1.0f;
}

/**
 * @brief Task to receive LoRa packets
 * 
 * Simple polling loop - matches working Inteform library exactly
 */
static void lora_rx_task(void *pvParameters)
{
    ESP_LOGI(TAG, "LoRa RX task started - waiting for sensor data...");
    
    static int loop_count = 0;
    
    while (1) {
        loop_count++;
        
        // Check if UI requested a locate ping
        if (ui_check_locate_pending()) {
            ESP_LOGI(TAG, "Sending LOCATE ping to sensor...");
            esp_err_t err = lora_send_ping(LORA_DEVICE_ID_REMOTE, ui_is_locate_enabled());
            if (err == ESP_OK) {
                ESP_LOGI(TAG, "Locate ping sent successfully");
            } else {
                ESP_LOGW(TAG, "Locate ping failed: %s", esp_err_to_name(err));
            }
        }
        
        // Check if UI changed config (refresh rate, high power)
        if (ui_check_config_pending()) {
            ESP_LOGI(TAG, "Sending CONFIG to sensor...");
            static uint8_t config_seq = 0;
            config_payload_t config = {
                .update_interval = ui_get_refresh_rate(),
                .tx_power = ui_is_sensor_high_power() ? TX_POWER_HIGH : TX_POWER_LOW,
                .flags = CFG_ADAPTIVE_POWER | (ui_is_sensor_high_power() ? CFG_HIGH_POWER : 0),
                .config_sequence = ++config_seq
            };
            esp_err_t err = lora_send_config(LORA_DEVICE_ID_REMOTE, &config);
            if (err == ESP_OK) {
                ESP_LOGI(TAG, "Config sent: interval=%ds, power=%d, flags=0x%02X", 
                         config.update_interval, config.tx_power, config.flags);
            } else {
                ESP_LOGW(TAG, "Config send failed: %s", esp_err_to_name(err));
            }
        }
        
        // Retry pending config if sensor hasn't ACKed yet
        lora_config_retry_check();
        
        // Enter receive mode
        lora_receive();
        
        // Poll for received packets
        while (lora_received()) {
            ESP_LOGI(TAG, ">>> Packet detected!");
            bool processed = lora_process_rx();
            ESP_LOGI(TAG, ">>> Process: %s", processed ? "OK" : "FAILED");
            lora_receive();
        }
        
        // Debug every ~10 seconds
        if (loop_count % 1000 == 0) {
            lora_status_t st;
            lora_get_status(&st);
            ESP_LOGI(TAG, "RX loop %d: RX=%lu, rejected=%lu, CRC_err=%lu", 
                     loop_count, st.packets_received, st.packets_rejected, st.crc_errors);
        }
        
        vTaskDelay(1);
        
        // Check if sensor has timed out
        if (last_sensor_data_time != 0) {
            TickType_t elapsed = (xTaskGetTickCount() - last_sensor_data_time) * portTICK_PERIOD_MS;
            if (elapsed > SENSOR_TIMEOUT_MS) {
                // Sensor timed out - mark as disconnected
                weather_data_t timeout_update = {
                    .temperature = 0,
                    .humidity = 0,
                    .pressure = 0,
                    .lightning_dist = -1,
                    .sensor_connected = false
                };
                if (weather_queue != NULL) {
                    xQueueOverwrite(weather_queue, &timeout_update);
                }
                last_sensor_data_time = 0;  // Reset so we don't spam
                ESP_LOGW(TAG, "Sensor timeout - no data for %d seconds", SENSOR_TIMEOUT_MS / 1000);
            }
        }
    }
}

/**
 * @brief Task to handle UI updates
 */
static void ui_task(void *pvParameters)
{
    weather_data_t weather;
    TickType_t last_refresh = 0;
    const TickType_t refresh_interval = pdMS_TO_TICKS(500);  // Max 2Hz refresh
    
    ESP_LOGI(TAG, "UI task started");
    
    while (1) {
        // Check for pending refresh from button press (deferred from button task)
        ui_check_refresh();
        
        // Check for new weather data
        if (xQueueReceive(weather_queue, &weather, pdMS_TO_TICKS(50)) == pdTRUE) {
            // Got new data, update UI
            ui_update_weather(&weather);
            last_refresh = xTaskGetTickCount();
        } else {
            // No new data, but still refresh periodically for animations/clock
            TickType_t now = xTaskGetTickCount();
            if ((now - last_refresh) >= refresh_interval) {
                ui_refresh();
                last_refresh = now;
            }
        }
        
        // Small delay to prevent busy-waiting
        vTaskDelay(pdMS_TO_TICKS(20));
    }
}

void app_main(void)
{
    ESP_LOGI(TAG, "WeatherKit starting...");

    // Initialize NVS (required for settings storage)
    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        ESP_LOGW(TAG, "NVS partition was truncated, erasing...");
        ESP_ERROR_CHECK(nvs_flash_erase());
        ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK(ret);
    ESP_LOGI(TAG, "NVS initialized");

    // Create weather data queue (single item, always overwrite with latest)
    weather_queue = xQueueCreate(1, sizeof(weather_data_t));
    if (weather_queue == NULL) {
        ESP_LOGE(TAG, "Failed to create weather queue!");
        return;
    }

    // Initialize storm tracker
    ESP_ERROR_CHECK(storm_tracker_init());
    ESP_LOGI(TAG, "Storm tracker initialized");

    // Initialize display hardware
    ESP_ERROR_CHECK(display_init());
    ESP_LOGI(TAG, "Display initialized");
    
    // Initialize UI system
    ESP_ERROR_CHECK(ui_init());
    ESP_LOGI(TAG, "UI initialized");
    
    // Load saved settings from flash
    ui_load_settings();
    
    // Apply loaded brightness setting
    display_set_brightness(ui_get_settings()->brightness);;
    
    // Initialize buttons with callback
    ESP_ERROR_CHECK(buttons_init(button_callback));
    ESP_LOGI(TAG, "Buttons initialized");
    
    // Initialize LoRa module
    ret = lora_init();
    if (ret == ESP_OK) {
        ESP_LOGI(TAG, "LoRa initialized");
        // Run diagnostics to verify hardware
        lora_run_diagnostics();
        
        // Set up callbacks for received data
        lora_set_weather_callback(on_weather_received);
        lora_set_status_callback(on_status_received);
        lora_set_weather_ack_ack_callback(on_weather_ack_ack_received);
        
        // Enable adaptive power - adjusts TX power based on link quality
        lora_set_adaptive_power(true);
        ESP_LOGI(TAG, "Adaptive power enabled");
    } else {
        ESP_LOGE(TAG, "LoRa init failed: %s - cannot receive sensor data!", esp_err_to_name(ret));
    }
    
    // Set initial state - waiting for sensor
    weather_data_t initial_weather = {
        .temperature = 0.0f,
        .humidity = 0.0f,
        .pressure = 0.0f,
        .lightning_dist = -1,
        .sensor_connected = false
    };
    ui_update_weather(&initial_weather);
    
    // Create tasks
    // Button task is created inside buttons_init()
    
    // LoRa receive task - medium-high priority
    if (lora_is_initialized()) {
        xTaskCreate(lora_rx_task, "lora_rx_task", 4096, NULL, 5, NULL);
    }
    
    // UI update task - medium priority
    xTaskCreate(ui_task, "ui_task", 4096, NULL, 4, NULL);
    
    ESP_LOGI(TAG, "WeatherKit Base Station ready!");
    ESP_LOGI(TAG, "Waiting for remote sensor data via LoRa...");
    ESP_LOGI(TAG, "Use LEFT/RIGHT buttons to navigate pages");
    
    // Main task can exit - everything runs in FreeRTOS tasks
    while (1) {
        vTaskDelay(pdMS_TO_TICKS(30000));
        
        // Periodic status log
        lora_status_t lora_status;
        lora_get_status(&lora_status);
        ESP_LOGI(TAG, "Status: Heap=%lu, LoRa RX=%lu, Sensor=%s",
                 (unsigned long)esp_get_free_heap_size(),
                 lora_status.packets_received,
                 (last_sensor_data_time != 0) ? "Connected" : "Waiting");
    }
}